// Copyright (C) 2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package controller

import (
	"sync"

	"github.com/ava-labs/avalanchego/ids"
	"github.com/ava-labs/hypersdk/crypto"
	"github.com/ava-labs/hypersdk/heap"
	"go.uber.org/zap"
)

// const (
// 	initialPairCapacity = 128
// 	allPairs            = "*"
// )

type Pool struct {
	ID    ids.ID `json:"id"`
	Owner string `json:"owner"` // we always send address over RPC
	// InTick    uint64 `json:"inTick"`
	// OutTick   uint64 `json:"outTick"`
	// Remaining uint64 `json:"remaining"`

	owner crypto.PublicKey
}

type MyPool struct {
	c *Controller

	// TODO: consider capping the number of pools in each heap (need to ensure
	// that doing so does not make it possible to send a bunch of small, spam
	// pools to clear -> may need to set a min order limit to watch)
	pools map[string]*heap.Heap[*Pool, float64]
	// pools      *heap.Heap[*Pool, float64]
	// orderToPair map[ids.ID]string // needed to delete from [CloseOrder] actions
	l sync.RWMutex

	// trackAll bool
}

// func NewMyPool(c *Controller, trackedPairs []string) *MyPool {
func NewMyPool(c *Controller) *MyPool {
	// m := map[string]*heap.Heap[*Pool, float64]{}
	m := map[string]*heap.Heap[*Pool, float64]{}
	// trackAll := false
	// if len(trackedPairs) == 1 && trackedPairs[0] == allPairs {
	// 	trackAll = true
	// 	c.inner.Logger().Info("tracking all order books")
	// } else {
	// 	for _, pair := range trackedPairs {
	// 		// We use a max heap so we return the best rates in order.
	// 		m[pair] = heap.New[*Order, float64](initialPairCapacity, true)
	// 		c.inner.Logger().Info("tracking order book", zap.String("pair", pair))
	// 	}
	// }
	return &MyPool{
		c:     c,
		pools: m,
		// orderToPair: map[ids.ID]string{},
		// trackAll:    trackAll,
	}
}

// func (o *MyPool) Add(pair string, pool *Pool) {
func (o *MyPool) Add(pool *Pool) {
	pair := "test"
	o.l.Lock()
	defer o.l.Unlock()

	h, ok := o.pools[pair]
	switch {
	// case !ok && !o.trackAll:
	// 	return
	// case !ok && o.trackAll:
	case !ok: //&& o.trackAll:
		o.c.inner.Logger().Info("tracking pool book", zap.String("pair", pair))
		h = heap.New[*Pool, float64](initialPairCapacity, true)
		o.pools[pair] = h
	}
	h.Push(&heap.Entry[*Pool, float64]{
		ID: pool.ID,
		// Val:   float64(pool.InTick) / float64(pool.OutTick),
		Item:  pool,
		Index: h.Len(),
	})
	// o.orderToPair[order.ID] = pair
}

// func (o *MyPool) Remove(id ids.ID) {
// 	o.l.Lock()
// 	defer o.l.Unlock()
// 	pair, ok := o.orderToPair[id]
// 	if !ok {
// 		return
// 	}
// 	delete(o.orderToPair, id)
// 	h, ok := o.pools[pair]
// 	if !ok {
// 		// This should never happen
// 		return
// 	}
// 	entry, ok := h.Get(id) // O(log 1)
// 	if !ok {
// 		// This should never happen
// 		return
// 	}
// 	h.Remove(entry.Index) // O(log N)
// }

// func (o *MyPool) UpdateRemaining(id ids.ID, remaining uint64) {
// 	o.l.Lock()
// 	defer o.l.Unlock()
// 	pair, ok := o.orderToPair[id]
// 	if !ok {
// 		return
// 	}
// 	h, ok := o.pools[pair]
// 	if !ok {
// 		// This should never happen
// 		return
// 	}
// 	entry, ok := h.Get(id)
// 	if !ok {
// 		// This should never happen
// 		return
// 	}
// 	entry.Item.Remaining = remaining
// }

func (o *MyPool) Pools(limit int) []*Pool {
	// func (o *MyPool) Pools(pair string, limit int) []*Order {
	pair := "test"
	o.l.RLock()
	defer o.l.RUnlock()

	h, ok := o.pools[pair]
	if !ok {
		return nil
	}
	items := h.Items()
	arrLen := len(items)
	if limit < arrLen {
		arrLen = limit
	}
	pools := make([]*Pool, arrLen)
	for i := 0; i < arrLen; i++ {
		pools[i] = items[i].Item
	}
	return pools
}
